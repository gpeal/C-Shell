/***************************************************************************
 *  Title: Input
 * -------------------------------------------------------------------------
 *    Purpose: Handles the input from stdin
 *    Author: Stefan Birrer
 *    Version: $Revision: 1.4 $
 *    Last Modification: $Date: 2009/10/12 20:50:12 $
 *    File: $RCSfile: interpreter.c,v $
 *    Copyright: (C) 2002 by Stefan Birrer
 ***************************************************************************/
/***************************************************************************
 *  ChangeLog:
 * -------------------------------------------------------------------------
 *    $Log: interpreter.c,v $
 *    Revision 1.4  2009/10/12 20:50:12  jot836
 *    Commented tsh C files
 *
 *    Revision 1.3  2009/10/11 04:45:50  npb853
 *    Changing the identation of the project to be GNU.
 *
 *    Revision 1.2  2008/10/10 00:12:09  jot836
 *    JSO added simple command line parser to interpreter.c. It's not pretty
 *    but it works. Handles quoted strings, and preserves backslash behavior
 *    of bash. Also, added simple skeleton code as well as code to create and
 *    free commandT structs given a command line.
 *
 *    Revision 1.1  2005/10/13 05:24:59  sbirrer
 *    - added the skeleton files
 *
 *    Revision 1.4  2002/10/24 21:32:47  sempi
 *    final release
 *
 *    Revision 1.3  2002/10/21 04:47:05  sempi
 *    Milestone 2 beta
 *
 *    Revision 1.2  2002/10/15 20:37:26  sempi
 *    Comments updated
 *
 *    Revision 1.1  2002/10/15 20:20:56  sempi
 *    Milestone 1
 *
 ***************************************************************************/
#define __INTERPRETER_IMPL__

/************System include***********************************************/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "string.h"

/************Private include**********************************************/
#include "interpreter.h"
#include "io.h"
#include "runtime.h"

/************Defines and Typedefs*****************************************/
/*  #defines and typedefs should have their names in all caps.
 *  Global variables begin with g. Global constants with k. Local
 *  variables should be in all lower case. When initializing
 *  structures and arrays, line everything up in neat columns.
 */
typedef struct string_l
{
  char* s;
  struct string_l* next;
} stringL;

int BUFSIZE = 512;
int MAXARGS = 100;

EXTERN Alias *aliases;

/**************Function Prototypes******************************************/

commandT* getCommand(char* cmdLine);

void freeCommand(commandT* cmd);

void locateCommand(commandT *cmd, char *path);

void parsePath(char **paths[], int *pathsc);

commandT* copyCommand(commandT* cmd);

/* External Declarations */
extern char* fgJobCmd;
/**************Implementation***********************************************/


/*
 * Interpret
 *
 * arguments:
 *   char *cmdLine: pointer to the command line string
 *
 * returns: none
 *
 * This is the high-level function called by tsh's main to interpret a
 * command line.
 */
void Interpret(char* cmdLine)
{
  commandT* cmd = getCommand(cmdLine);

  RunCmd(cmd, cmdLine);

  freeCommand(cmd);
} /* Interpret */

/*
 * getCommand
 *
 * arguments:
 *   char *cmdLine: pointer to the command line string
 *
 * returns: commandT*: pointer to the commandT struct generated by
 *                     parsing the cmdLine string
 *
 * This parses the command line string, and returns a commandT struct,
 * as defined in runtime.h.  You must free the memory used by commandT
 * using the freeCommand function after you are finished.
 *
 * This function tokenizes the input, preserving quoted strings. It
 * supports escaping quotes and the escape character, '\'.
 */
commandT* getCommand(char* cmdLine)
{
  Alias *alias;
  char *aliasTmp;
  char *cmdLineWords[15];
  char *cmdLineRunnerHead;
  char *cmdLineRunnerTail;
  int cmdLineWord = 0;
  commandT* cmd = malloc(sizeof(commandT) + sizeof(char*) * MAXARGS);
  cmd->argv[0] = 0;
  cmd->name = 0;
  cmd->argc = 0;
  cmd->ioRedirect = IO_REDIRECT_NONE;
  cmd->ioRedirectPath = NULL;

  int i, inArg = 0;
  char quote = 0;
  char escape = 0;
  cmdLineRunnerHead = cmdLine;
  cmdLineRunnerTail = cmdLine;
  // make an array with every word in the command
  while(*cmdLineRunnerTail != '\0')
  {
    while(*cmdLineRunnerTail != ' ' && *cmdLineRunnerTail != '\0')
    {
      cmdLineRunnerTail++;
    }
    cmdLineWords[cmdLineWord] = malloc(sizeof(char) * (cmdLineRunnerTail - cmdLineRunnerHead + 1));
    strncpy(cmdLineWords[cmdLineWord], cmdLineRunnerHead, (cmdLineRunnerTail - cmdLineRunnerHead));
    // add the null terminator
    cmdLineWords[cmdLineWord][cmdLineRunnerTail - cmdLineRunnerHead] = '\0';
    cmdLineWord++;
    if (*cmdLineRunnerTail != '\0')
      cmdLineRunnerTail++;
    cmdLineRunnerHead = cmdLineRunnerTail;
  }

  // Replace all words with their aliases
  for (i = 0; i < cmdLineWord; i++)
  {
    alias = aliases;
    while (alias != NULL)
    {
      // printf("Comparing %s with %s\n", cmdLineWords[i], alias->from);
      if (strlen(cmdLineWords[i]) == strlen(alias->from) && strcmp(cmdLineWords[i], alias->from) == 0)
      {
        // printf("Replacing %s with %s\n", alias->from, alias->to);
        free(cmdLineWords[i]);
        cmdLineWords[i] = malloc(sizeof(char) * (strlen(alias->to) + 1));
        strcpy(cmdLineWords[i], alias->to);
      }
      alias = alias->next;
    }
  }

  // Put the aliased words back in cmdLine
  // set cmdLine to empty string
  *cmdLine = '\0';
  for (i = 0; i < cmdLineWord; i++)
  {
    strcat(cmdLine, " ");
    strcat(cmdLine, cmdLineWords[i]);
  }
  // printf("cmdLine: %s\n", cmdLine);
  
  // Set up the initial empty argument
  char* tmp = malloc(sizeof(char*) * BUFSIZE);
  int tmpLen = 0;
  tmp[0] = 0;

  //printf("parsing:%s\n", cmdLine);

  for (i = 0; cmdLine[i] != 0; i++)
    {
      //printf("\tindex %d, char %c\n", i, cmdLine[i]);

      // Check for whitespace
      if (cmdLine[i] == ' ')
        {
          if (inArg == 0)
            continue;
          if (quote == 0)
          {
            // End of an argument
            //printf("\t\tend of argument %d, got:%s\n", cmd.argc, tmp);
            cmd->argv[cmd->argc] = malloc(sizeof(char) * (tmpLen + 1));
            strcpy(cmd->argv[cmd->argc], tmp);

            inArg = 0;
            tmp[0] = 0;
            tmpLen = 0;
            cmd->argc++;
            cmd->argv[cmd->argc] = 0;
            continue;
          }
        }

      // If we get here, we're in text or a quoted string
      inArg = 1;

      // Start or end quoting.
      if (cmdLine[i] == '\'' || cmdLine[i] == '"')
        {
          if (escape != 0 && quote != 0 && cmdLine[i] == quote)
            {
              // Escaped quote. Add it to the argument.
              tmp[tmpLen++] = cmdLine[i];
              tmp[tmpLen] = 0;
              escape = 0;
              continue;
            }

          if (quote == 0)
            {
              //printf("\t\tstarting quote around %c\n", cmdLine[i]);
              quote = cmdLine[i];
              continue;
            }
          else
            {
              if (cmdLine[i] == quote)
                {
                  //printf("\t\tfound end quote %c\n", quote);
                  quote = 0;
                  continue;
                }
            }
        }

      // Handle escape character repeat
      if (cmdLine[i] == '\\' && escape == '\\')
        {
          escape = 0;
          tmp[tmpLen++] = '\\';
          tmp[tmpLen] = 0;
          continue;
        }

      // Handle single escape character followed by a non-backslash or quote character
      if (escape == '\\')
        {
          if (quote != 0)
            {
              tmp[tmpLen++] = '\\';
              tmp[tmpLen] = 0;
            }
          escape = 0;
        }

      // Set the escape flag if we have a new escape character sequence.
      if (cmdLine[i] == '\\')
        {
          escape = '\\';
          continue;
        }

      tmp[tmpLen++] = cmdLine[i];
      tmp[tmpLen] = 0;
    }
  // End the final argument, if any.
  if (tmpLen > 0)
  {
    //printf("\t\tend of argument %d, got:%s\n", cmd.argc, tmp);
    cmd->argv[cmd->argc] = malloc(sizeof(char) * (tmpLen + 1));
    strcpy(cmd->argv[cmd->argc], tmp);

    inArg = 0;
    tmp[0] = 0;
    tmpLen = 0;
    cmd->argc++;
    cmd->argv[cmd->argc] = 0;
  }

  free(tmp);

  cmd->name = cmd->argv[0];

  // determine whether it is a background job or not
  if ((cmd->argc > 0) && strcmp(cmd->argv[cmd->argc - 1], "&") == 0)
  {
    free(cmd->argv[cmd->argc - 1]);
    cmd->argv[cmd->argc - 1] = 0;
    (cmd->argc)--;
    cmd->bg = 1;
  }
  else
    cmd->bg = 0;

  return cmd;
} /* getCommand */


/*
 * freeCommand
 *
 * arguments:
 *   commandT *cmd: pointer to the commandT struct to be freed
 *
 * returns: none
 *
 * This function frees all the memory associated with the given
 * commandT struct, before freeing the struct's memory itself.
 */
void freeCommand(commandT* cmd)
{
  int i;

  if (cmd->name != cmd->argv[0] && cmd->name != NULL)
  {
      free(cmd->name);
  }

  if (cmd->ioRedirectPath != NULL)
  {
    free(cmd->ioRedirectPath);
  }

  cmd->name = 0;
  for (i = 0; i < cmd->argc; i++)
    {
      if(cmd->argv[i] != NULL)
      {
      	free(cmd->argv[i]);
      	cmd->argv[i] = 0;
      }
    }
  free(cmd);
} /* freeCommand */

char* copyString(char* str)
{
  if(str == NULL)
    return NULL;
  return strndup(str, strlen(str));
}

/* Provides a newly allocated copy of the cmd struct  */
commandT *copyCommand(commandT* cmd)
{
  int i;
  commandT* cmd_copy = malloc(sizeof(commandT) + sizeof(char*) * MAXARGS);
  cmd_copy->name = copyString(cmd->name);
  cmd_copy->argc = cmd->argc;
  cmd_copy->bg = cmd->bg;
  cmd_copy->ioRedirect = cmd->ioRedirect;
  cmd_copy->ioRedirectPath = copyString(cmd->ioRedirectPath);
  for(i=0; i < cmd->argc; i++)
  {
    cmd_copy->argv[i] = copyString(cmd->argv[i]);
  }
  return cmd_copy;
}
